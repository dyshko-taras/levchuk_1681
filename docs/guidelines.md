# ⚙️ Project Guidelines — Flutter App (Global)

This is a **cross-project** coding guide. It defines structure, style, and contracts for tokens/assets.

> **Normative precedence**
>
> 1. **PRD** (per-project)
> 2. **Implementation Plan** (per-project)
> 3. **This Global Guide**
>    If any conflict exists → **PRD wins**. Do **not** infer domain models, screens, or routes for a specific app from generic examples below.

---

## 📦 Project Structure (lib/)

```
lib/
├── app.dart                      # App root: MaterialApp, theme setup, top-level providers
├── main.dart                     # Entry point: runApp(), platform/bootstrap init
│
├── core/                         # Cross-cutting concerns
│   ├── endpoints.dart            # Base URLs and API route paths
│   └── env.dart                  # Environment flags (dev/prod) and runtime switches
│
├── constants/                    # Design tokens & asset constants (see “Constants contract”)
│   ├── app_config.dart
│   ├── app_icons.dart
│   ├── app_images.dart
│   ├── app_routes.dart
│   ├── app_strings.dart
│   ├── app_radius.dart
│   ├── app_sizes.dart
│   ├── app_durations.dart
│   └── app_spacing.dart
│
├── utils/                        # Common utilities (formatters, validators, etc.)
│
├── data/                         # Data layer (API, DB, repositories)
│   ├── api/
│   │   ├── api_client.dart          # Dio client
│   │   ├── <feature>_service.dart   # Retrofit service interfaces
│   │   └── <feature>_service.g.dart # generated by retrofit
│   ├── local/
│   │   ├── memory_cache.dart
│   │   ├── prefs_store.dart
│   │   └── database/
│   │       ├── app_database.dart
│   │       ├── schema/          # table/entity definitions
│   │       └── dao/             # typed queries
│   ├── models/
│   │   ├── <feature>.dart           # json_serializable model
│   │   └── <feature>.g.dart         # generated by json_serializable
│   └── repositories/
│       └── <feature>_repository.dart
│
├── enums/
│   └── enums.dart
│
├── providers/                    # Business logic (ChangeNotifier)
│   └── <feature>_provider.dart
│
└── ui/
    ├── theme/                    # Color, fonts, ThemeData
    │   ├── app_fonts.dart
    │   ├── app_colors.dart
    │   └── app_theme.dart
    ├── pages/                    # Screens
    │   ├── home_page.dart
    └── widgets/                  # Reusable UI
        ├── common/
        ├── buttons/
        ├── dialogs/
        ├── fields/
        └── navigation/
```

> **LLM rule:** Filenames with `<feature>` are **generic examples**. Use app-specific names only if they are defined in the **PRD**.

---

## 🧠 State Management

- Primary approach: **Provider** (+ `ChangeNotifier`) in `lib/providers/`.
- Business logic lives in providers; widgets are dumb (display/interaction only).

### Granularity Rules
- **Providers are feature/domain–scoped, not page-scoped.**  
    Example: `UserProvider` handles all user-related state and can be used across multiple screens (`UserListPage`, `UserDetailsPage`).
- Do **not** create one provider per screen if they belong to the same domain — this causes duplicated logic and inconsistent state.
- Multiple pages can consume the same provider instance if they share business logic.
- Providers expose only domain-specific state and actions; they should not depend on UI details.

## 🌐 Networking

*Networking layer uses `Dio` + `Retrofit` + `json_serializable`.*

### Structure

* **`data/api/api_client.dart`** — base Dio client (baseUrl, timeouts, interceptors).
* **`data/api/<feature>_service.dart`** — Retrofit interface (`@GET`, `@POST`, etc.).
* **`data/models/<feature>.dart`** — model annotated with `@JsonSerializable()`.
* **`data/repositories/<feature>_repository.dart`** — encapsulates API access.
* **`providers/<feature>_provider.dart`** — manages state and calls repository.

### Example

**api\_client.dart**

```dart
import 'package:dio/dio.dart';
import '../../core/endpoints.dart';

class ApiClient {
  static final Dio dio = Dio(
    BaseOptions(
      baseUrl: Endpoints.baseUrl,
      connectTimeout: const Duration(seconds: 10),
      receiveTimeout: const Duration(seconds: 10),
      headers: {'Content-Type': 'application/json'},
    ),
  );

  static void addInterceptors() {
    dio.interceptors.add(LogInterceptor(responseBody: true));
  }
}
```

**user\_service.dart**

```dart
import 'package:retrofit/retrofit.dart';
import 'package:dio/dio.dart';
import '../models/user.dart';
import 'api_client.dart';

part 'user_service.g.dart';

@RestApi()
abstract class UserService {
  factory UserService(Dio dio, {String baseUrl}) = _UserService;

  @GET('/users')
  Future<List<User>> getUsers();

  @GET('/users/{id}')
  Future<User> getUser(@Path("id") int id);
}

UserService createUserService() =>
    UserService(ApiClient.dio, baseUrl: ApiClient.dio.options.baseUrl);
```

**user.dart**

```dart
import 'package:json_annotation/json_annotation.dart';

part 'user.g.dart';

@JsonSerializable()
class User {
  final int id;
  final String name;
  final String email;

  User({required this.id, required this.name, required this.email});

  factory User.fromJson(Map<String, dynamic> json) =>
      _$UserFromJson(json);
  Map<String, dynamic> toJson() => _$UserToJson(this);
}
```

---

## ✅ Restrictions (LLM Guardrails)

* Use **only `json_serializable`** for data models.
* Retrofit services must be **generated with `build_runner`**, not handwritten.
* All HTTP requests must go through **Dio** (via Retrofit).
* Repositories abstract API services, Providers manage state.
* Never call Dio directly from UI or Provider.

---

## 🧭 Navigation (`app_routes.dart`)

1. Centralize all route names in `constants/app_routes.dart`.
2. Use `initialRoute` + `routes`.
3. Root navigation uses **MainShellPage + BottomNavProvider + IndexedStack**.
4. Register each **tab route** (e.g. `/home`, `/schedule`, `/stats`, `/settings`) to return the **same** `MainShellPage` with different `initialIndex`.
5. Do **not** register tab pages themselves as top-level routes.
6. Deep links: navigating to a tab route should show `MainShellPage` with the correct index.
7. Non-tab detail pages (e.g., item details, forms) can be registered as standard routes in `AppRoutes.routes` outside of the shell.

Example code
```dart
// constants/app_routes.dart
import 'package:flutter/material.dart';
import '../ui/pages/main_shell_page.dart';

class AppRoutes {
  // Pages
  static const String welcome = '/welcome';

  // Shell
  static const String main = '/main';

  // Tab routes
  static const String home = '/home';
  static const String schedule = '/schedule';
  static const String stats = '/stats';

  static Map<String, WidgetBuilder> routes = {
    welcome: (_) => const WelcomePage(),
    home:(_) => const MainShellPage(initialIndex: 0),
    schedule:(_) => const MainShellPage(initialIndex: 1),
    stats:(_) => const MainShellPage(initialIndex: 2),
  };
}
```

---

## 🎨 Theme (`app_theme.dart`)

* **Material 3** (`useMaterial3: true`), single theme (no light/dark unless PRD says otherwise).
* Define `ColorScheme` (recommended: `ColorScheme.fromSeed`) and bind typography via `TextTheme`.
* Keep component themes here (`AppBarTheme`, `CardTheme`, inputs, buttons, etc.).
* Use colors from `app_colors.dart`, fonts from `app_fonts.dart`.

```dart
// ui/theme/app_theme.dart (sketch)
final ThemeData appTheme = ThemeData(
  useMaterial3: true,
  colorScheme: ColorScheme.fromSeed(seedColor: const Color(0xFFA77CFF), brightness: Brightness.dark),
  textTheme: TextTheme(
    titleLarge: const TextStyle(fontSize: 20, fontWeight: FontWeight.w600),
    bodyMedium: const TextStyle(fontSize: 14),
  ),
);
```

---

## 📚 Constants (Tokens & Assets) — **Contract for LLM**

**Purpose.** These files are the **single source of truth** for design tokens and asset paths.
**Never** hardcode numbers for spacing/radius/durations, and **never** use raw `'assets/...'` strings in widgets.

### Assets

* `lib/constants/app_icons.dart` — SVG icons.
  *Use:* `SvgPicture.asset(AppIcons.home)`
* `lib/constants/app_images.dart` — raster/photos & helpers
  *Use:* `Image.asset(AppImages.welcomeHero)`

**Rules**

* Do **not** write raw paths like `'assets/icons/home.svg'`.
* Use only `AppIcons.*` and `AppImages.*`.

### Design Tokens

* `app_spacing.dart` — spacing helpers: `AppSpacing` (xs/sm/md/…), `Gaps` (ready `SizedBox`), `Insets` (EdgeInsets), `NumSpaceExtension` (`12.h`, `8.w`).
* `app_sizes.dart` — component sizes (e.g., `Sizes.donutSize`).
* `app_radius.dart` — `BorderRadius` tokens (`AppRadius.sm/md/lg/xl/pill`).
* `app_durations.dart` — UX timings (e.g., `AppDurations.splashMin`, animations).

**Examples**

```dart
// Spacing (no magic numbers)
Padding(padding: Insets.allMd, child: Column(children: [Gaps.hSm, 16.h]));

// Sizes + Radius
Container(height: Sizes.donutSize, decoration: const BoxDecoration(borderRadius: AppRadius.lg));

// Duration
await Future.delayed(AppDurations.splashMin);

// Assets
SvgPicture.asset(AppIcons.settings);
Image.asset(AppImages.welcomeHero);
```

> **LLM rules (strict):**
> • Do **not** invent new token/asset files. Use **only** the files above.
> • If an example here conflicts with PRD/Implementation Plan → **follow PRD**.
> • Do **not** inline raw numbers for spacing/radius/durations.

---

## 📐 Spacing / Layout

* **No magic numbers** for padding/margins/gaps—use `AppSpacing`, `Gaps`, `Insets`, `NumSpaceExtension`.
* Keep visual rhythm consistent (vertical rhythm via `Gaps.h*`, horizontal via `Gaps.w*`).

```dart
Padding(
  padding: Insets.allMd,
  child: Row(children: [const Icon(Icons.star), Gaps.wMd, const Expanded(child: Text('Item'))]),
);
```

---

## 🗂 Assets Folder Structure

```
assets/
├── fonts/
├── icons/            # SVG (preferred)
└── images/
```

> Register folders in **pubspec.yaml** and keep all lookups via `AppIcons` / `AppImages`.

```yaml
flutter:
  uses-material-design: true
  assets:
    - assets/icons/
    - assets/images/
```

---

## 🚀 App Entry

* `main.dart` → only `runApp(const App())`.
* `app.dart` → `MultiProvider`, `MaterialApp`, `initialRoute`, `routes: AppRoutes.routes`, `theme: appTheme`.

---

## 📦 Recommended Packages

Keep dependencies up to date. Use listed packages for their specific concerns:

```yaml
dependencies:
  provider: ^6.1.5
  drift: ^2.28.1
  path_provider: ^2.1.5
  shared_preferences: ^2.5.3
  sqlite3_flutter_libs: ^0.5.20
  flutter_svg: ^2.2.0
  table_calendar: ^3.2.0
  fl_chart: ^1.0.0
  percent_indicator: ^4.2.5
  flutter_datetime_picker_plus: any
  flutter_colorpicker: any
  dio: any
  retrofit: any
  json_annotation: any

dev_dependencies:
  very_good_analysis: ^9.0.0
  build_runner: ^2.4.9
  json_serializable: ^6.8.0
```

> Use `flutter_svg` for all vector icons. `drift` + `sqlite3_flutter_libs` for local DB. `provider` for state management.

---

## ✅ Restrictions (LLM Guardrails)

* Repositories abstract data sources (API, DB, cache). They do not contain business logic — only data fetching and mapping.
* Generate **complete, runnable code** (with imports) — no TODOs/pseudocode.
* State management: **Provider + ChangeNotifier** (business logic only in providers).
* Navigation: use `AppRoutes.routes` (or project router per PRD).
* Spacing/tokens: **no inline numbers** — use `AppSpacing/Gaps/Insets/NumSpaceExtension`, `AppRadius`, `AppDurations`, `Sizes`.
* Resources: use **only** `AppImages` / `AppIcons` (no raw asset strings).
* Theme: use types from `app_theme.dart` / `app_colors.dart` / `app_fonts.dart`.
* If a UI element repeats ≥ 2 times — extract a private widget in the same file.

---